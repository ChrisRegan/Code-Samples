--[[

This file manages the gameState as well as the tiles.  Had to combine the files as the message system runs too late to determine if
the new row has 4 or more of the same color on the line.


--]]

local tileFactory = "#TileFactory"
local rowPos = {
	vmath.vector3(103,611, 1),
	vmath.vector3(167,611, 1),
	vmath.vector3(231,611, 1),
	vmath.vector3(295,611, 1),
	vmath.vector3(359,611, 1),
	vmath.vector3(423,611, 1)
}
<<<<<<< Updated upstream
local updateState=function()end
local gameState={}
local numberRows = 8
local speed = 200.0  --Max speed 200
local spawnHeight = 547

local timePassed = 0
local moveDownTime
local const_MoveDownTime = 0.6 -- Constant value to ensure that the base value can be reset when needed
-- 2.6 4th beat of 100 bpm
local grabbed = nil
local tileHeight = 64
=======
local updateState=function()end -- Manages the update loop to help prevent running unnecessary code in the update loop.
>>>>>>> Stashed changes

local minTileMatch = 3

local gameState={} 				-- tracks the gameState by keeping track of the rows, filled with the tileData
local numberRows = 8			-- Max number of rows until the game is over.
local speed = 200.0 			-- Speed the tiles fall
local spawnHeight = 547			-- Height needed to spawn the new row

local timePassed = 0			-- used to keep track of the time until the blocks move down.
local moveDownTime				-- varible that tracks when the tiles move down. may change based on the player input.
local const_MoveDownTime = 0.6 	-- Normal time it takes to move the tiles down.  
local grabbed = nil				-- Tile data of the tile that the player has grabbed used to reinsert back into the gameState \
local capture = 4				-- Min number of tiles connected to clear from the board
local tileHeight = 64

local messages = {}				-- Stores the functions to be used by the message system by the message_id.  Initialized in the init function



local function verifyColRow(tileData)
	if tileData == nil then
		return
	end

	if tileData["rowNum"] then
		pprint(tileData)
	end

	if tileData["colNum"] then
		pprint(tileData)
	end
end

local function isGameOver()
	if #gameState >= numberRows then
		updateState = function()end

		pprint(gameState)
	end
end

<<<<<<< Updated upstream
=======
local function isTileValid(row, col)
	return gameState[row] ~= nil and gameState[row][col] ~= nil
end


-- Compares the desired tile against the row and column to see if the color matches.
local function compareTiles(row, col, tileData, searched)
	if isTileValid(row, col) and gameState[row][col]["color"] == tileData["color"] then
		for i = 1, #searched, 1 do
			if searched[i]["tile"] == gameState[row][col]["tile"] then
				return nil
			end
		end	

		return gameState[row][col]
	end

	return nil
end



local function countColor(tileData)

	local foundColors = {tileData}
	local searched = {}
	repeat
		local t = table.remove(foundColors)
		table.insert(searched, t)

		local row = t["RowNum"]
		local col = t["ColNum"]

		table.insert(foundColors, compareTiles(row+1, col, t, searched))
		table.insert(foundColors, compareTiles(row-1, col, t, searched))
		table.insert(foundColors, compareTiles(row, col+1, t, searched))
		table.insert(foundColors, compareTiles(row, col-1, t, searched))
	until(#foundColors == 0)

	return searched

end

-- Removes the empty tables to ensure the game doesnt end early
>>>>>>> Stashed changes
local function checkEmpty(rowNumber)
	if tablelength(gameState[rowNumber]) == 0 then
		table.remove(gameState, rowNumber)
	end
end


-- Used to shuffle the table of colors to randomize the new colors.
local function shuffle(colors)
	local shuffledTable = {}
	while #colors > 0 do
		local rand = math.random(#colors)
		local color = colors[rand]
		table.insert(shuffledTable, color)
		table.remove(colors, rand)
	end
	return shuffledTable
end

<<<<<<< Updated upstream
local function NewColor (colors, tile)
	local color = table.remove(colors)
	msg.post(tile .. "#tileSprite", "play_animation", {id = hash(color)})
end


local function countNext(data, nextCount, dataName)
	if data[dataName] ~= nil then
		nextCount = countNext(data[dataName], nextCount + 1, dataName)
	end
	return nextCount
end

local function countColor(data)

	return countNext(data, 0, "next") + countNext(data, 0, "prev") + 1

end

--[[local function verifyTile(col, row)
	
	return gameState[row] ~= nil and gameState[row][col] ~= nil
end

local function DisconnectTile(row, col)
	local tileData = gameState[row][col]

	if tileData["next"] ~= nil then
		tileData["next"]["prev"] = tileData["prev"]
	end

	if tileData["prev"] ~= nil then
		tileData["prev"]["next"] = tileData["next"]
	end

	tileData["next"] = nil
	tileData["prev"] = nil
	tileData["rowNum"] = nil
	tileData["colNum"] = nil
end

local function goToEnd(tileData, direction)
	local endData = tileData;
	if tileData[direction] ~= nil then
		endData = goToEnd(tileData[direction])
	end

	return endData
end


local function isInHead(tileA, tileB, direction)
	local found = false;

	if tileA["tile"] == tileB["tile"] then
		found = true
	elseif tileA[direction] ~= nil then
		found = isInHead(tileA[direction], tileB, direction)
	end

	return found
		
end

local function inSameList(tileA, tileB)
	local found = isInHead(tileA, tileB, "next")
	if not found then
		found = isInHead(tileA, tileB, "prev")
	end

	return found
end

local function CombineList(listA, listB)
	if not inSameList(listA, listB) then
		local tail = goToEnd(listA, "next")
		local head = goToEnd(listB, "prev")

		head["prev"] = tail
		tail["next"] = head

		return true	
	end

	return false
end

local function ConnectTile(row, col)
	local tileData = gameState[row][col]
	local validTiles = {tileData}
	
	if gameState[row-1] ~= nil and gameState[row-1][col] ~= nil and gameState[row-1][col]["color"] == tileData["color"] then
		table.insert(validTiles, gameState[row-1][col])
	end

	if gameState[row+1] ~= nil and gameState[row+1][col] ~= nil and gameState[row+1][col]["color"] == tileData["color"] then
		table.insert(validTiles, gameState[row+1][col])
	end

	if gameState[row][col-1] ~= nil and gameState[row][col-1]["color"] == tileData["color"] then
		table.insert(validTiles, gameState[row][col-1])
	end

	if gameState[row][col+1] ~= nil and gameState[row][col+1]["color"] == tileData["color"] then
		table.insert(validTiles, gameState[row][col+1])
	end

	for i = 1, #validTiles - 1, 1 do
		CombineList(validTiles[i], validTiles[i+1])
	end

end--]]

=======
local function findTile(row)
	local tile = nil
	for key, value in pairs(row) do 
		if value ~= nil then
			tile = value
			break
		end
	end
	return tile
end
>>>>>>> Stashed changes


-- Check against all the colors for the  new tile and return all colors that will not pass the minimum collect threshold.

local function validColors()
	local leftTile = gameState[1][#gameState[1] - 1]
	local sumColors = {BlueTile = 0, GreenTile = 0, PurpleTile = 0, RedTile = 0, YellowTile = 0}
<<<<<<< Updated upstream

	if leftTile then
		sumColors[leftTile["color"]] = sumColors[leftTile["color"]] + countColor(leftTile)	
	end
	if gameState[2] ~= nil and gameState[2][#gameState[1]] then
		local belowTile = gameState[2][#gameState[1]]

		if belowTile then
			sumColors[belowTile["color"]] = sumColors[belowTile["color"]] + countColor(belowTile)	
		end
	end	

	local included = {}
	for color, sum in pairs(sumColors) do
		if sum < 2 then
=======
	
	for color, count in pairs(sumColors) do
		tileData["color"] = color
		sumColors[color] = #countColor(tileData)
	end

	local included = {}
	for color, sum in pairs(sumColors) do
		if sum < capture-1 then
>>>>>>> Stashed changes
			table.insert(included, color)
		end
	end

	return included
end


-- Initializes the tile data when spawned into the game.
local function generateTile(self, pos)
	local tile = factory.create(tileFactory, pos)
<<<<<<< Updated upstream
	table.insert(gameState[1], {tile = tile, rowNum = 1, colNum = #gameState[1]+1})
=======

	
	table.insert(gameState[1], {tile = tile, RowNum = 1, ColNum = #gameState[1]+1 })
>>>>>>> Stashed changes
	
	local colors = shuffle(validColors())
	local color = table.remove(colors)
	gameState[1][#gameState[1]]["color"] = color
	msg.post(tile, "play_animation", {id = hash(color)})
<<<<<<< Updated upstream
	--countConnecting({#gameState[1], 1})

--	ConnectTile(1, #gameState[1])
=======
>>>>>>> Stashed changes
	
	
end

local function checkConnections(tileData)

	local row = tileData["rowNum"]
	local col = tileData["colNum"]

	local printNode = false
	
	if gameState[row] ~= nil and gameState[row][col+1] ~= nil and tileData["color"] == gameState[row][col+1]["color"] and not inSameList(tileData, gameState[row][col+1]) then
		pprint("Error: right not in list")
		printNode = true
	end

	if gameState[row] ~= nil and gameState[row][col-1] ~= nil and tileData["color"] == gameState[row][col-1]["color"] and not inSameList(tileData, gameState[row][col-1]) then
		pprint("Error: left not in list")
		printNode = true
	end

	if gameState[row+1] ~= nil and gameState[row+1][col] ~= nil and tileData["color"] == gameState[row+1][col]["color"] and not inSameList(tileData, gameState[row+1][col]) then
		pprint("Error: down not in list")
		printNode = true
	end

	if gameState[row-1] ~= nil and gameState[row-1][col] ~= nil and tileData["color"] == gameState[row-1][col]["color"] and not inSameList(tileData, gameState[row-1][col]) then
		pprint("Error: up not in list")
		printNode = true
	end

	if printNode then
		pprint(tileData)
	end
end

local function spawnRow(self, tile)
	local row={}
	table.insert(gameState, 1, row)
	
	if gameState[2] == nil then

		for colNum, pos in ipairs(rowPos) do
			generateTile(self, pos)
			--table.insert(row, generateTile(pos, #row))
		end

	else
		for colNum, pos in ipairs(rowPos) do
			pos['y'] = tile + tileHeight
			generateTile(self, pos)
		end

		for i = 2, #gameState, 1 do
			for key, value in pairs(gameState[i]) do
				value["rowNum"] = value["rowNum"]+1
			end
		end


		
		isGameOver()
	end

	
end

<<<<<<< Updated upstream


local function findTile_Row(row)
	local tile = nil
	for key, value in pairs(row) do 
		if value ~= nil then
			tile = value
			break
		end
	end
	return tile
end

local function printTileNames()

	local list = {}
	for key, value in pairs(gameState) do
		table.insert(list, {})
		for k, v in pairs(value) do
			table.insert(list[key], v["tile"])
		end
	end

	pprint(list)
end


=======
>>>>>>> Stashed changes
local function GamePlaying(self, dt)
	-- Add update code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed

	timePassed = timePassed + dt

	if timePassed >= moveDownTime then
		timePassed = 0

<<<<<<< Updated upstream
		
		--printTileNames()
		
=======
>>>>>>> Stashed changes
		for rowNum, row in ipairs(gameState) do

			for tileNum, tile in pairs(row) do

				if tile ==  nil then
					pprint(rowNum, tileNum)
				end
				
				local pos = go.get_position(tile["tile"])
				pos = pos - (vmath.vector3(0,1,0) * speed) * dt
				go.set_position(pos, tile["tile"])
			end
		end

<<<<<<< Updated upstream
		-- Check if first row

		local tilePos = go.get_position(findTile_Row(gameState[1])["tile"])['y']
=======
		--Check if the first row made it to the spawnHeight
		local tilePos = go.get_position(findTile(gameState[1])["tile"])['y']
>>>>>>> Stashed changes
		if tilePos <= spawnHeight then
			spawnRow(self, tilePos)
		end
	end
end


local function printGameState()
	-- Debug print the current state of the game
	pprint("-----")
	for k, v in pairs(gameState) do
		local colors={}

		for key, value in pairs(v) do
			colors[key] = value["color"]
		end

		pprint(colors)
	end
	pprint("-----")
end

local function captureTile(tData)

	local matchingTiles = countColor(tData)
	if #matchingTiles > capture-1 then


		updateState = function(self,dt)pprint("hold")end

		timePassed = 0
		printGameState()


		for key = #matchingTiles, 1, -1 do
			go.delete(matchingTiles[key]["tile"])
			gameState[matchingTiles[key]["RowNum"]][matchingTiles[key]["ColNum"]] = nil
			msg.post(matchingTiles[key]["tile"], "disable")
		end





		--[[local lowest = {}

		for key, tileData in pairs(matchingTiles) do
			if lowest[tileData["ColNum"]] == nil or lowest[tileData["ColNum"]] > tileData["RowNum"] then
				lowest[tileData["ColNum"]] = tileData["RowNum"]
			end
		end

		local changed = {}

		for colNum, rowNum in pairs(lowest) do
			for i = rowNum+1, #gameState, 1 do
				if gameState[i][colNum] ~= nil then

					local t = gameState[i][colNum]
					local pos = go.get_position(t["tile"])
					pos["y"] = (i - rowNum) * tileHeight + pos["y"]
					go.set_position(pos, t["tile"])

					if gameState[rowNum][colNum] ~= nil then
						pprint(gameState[rowNum][colNum])

						printGameState()
					end
					
	
					gameState[rowNum][colNum] = gameState[i][colNum]
					gameState[i][colNum] = nil

					gameState[rowNum][colNum]["RowNum"] = rowNum

					--table.insert(changed, gameState[rowNum][colNum])

				end
			end
		end

		pprint(changed)--]]


	--[[	for key, tileData in ipairs(changed) do
			captureTile(tileData)
		end--]]


		for rowNumber, row in ipairs(gameState) do
			checkEmpty(rowNumber)
		end

		updateState = GamePlaying

	end
end

local function moveUpTiles(self, dt)
	timePassed = timePassed + dt

	if timePassed >= moveDownTime then
		timePassed = 0

		
	end
end



function tablelength(T)
	local count = 0
	for _ in pairs(T) do count = count + 1 end
	return count
end


local function SpeedUp(self, message_id, message, sender)
	if message[2].pressed then
		speed = 150
		moveDownTime = 0
	elseif message[2].released then
		speed = 200
		moveDownTime = const_MoveDownTime
	end
end

local function deleteDirection(node, direction)
	local colAffected = {}

	if node[direction] ~= nil then
		colAffected = deleteDirection(node[direction], direction)
	end


	go.delete(node["tile"])
	--pprint(node)

	if node == nil or node["colNum"] == nil or node["rowNum"] == nil then
		pprint(node)
		pprint(node["colNum"])
		pprint(node["rowNum"])
	end
	
	gameState[node["rowNum"]][node["colNum"]] = nil

	if colAffected[node["colNum"]] == nil or colAffected[node["colNum"]] > node["rowNum"] then
		colAffected[node["colNum"]] = node["rowNum"]
	end

	return colAffected
end

local function findNil(col, startIndex)
	for RowNumber = startIndex, #gameState, 1 do
		if gameState[RowNumber][col] == nil then
			return RowNumber
		end
	end

	return nil
end

local function findTile_Col(col, startIndex)
	for RowNumber = startIndex, #gameState, 1 do
		if gameState[RowNumber][col] ~= nil then
			return RowNumber
		end
	end

	return nil
	
end

local function adjustColumn(colnum, rownum)
	local changedTiles = {}

	for i = rownum, #gameState, 1 do
		local tileIndex = findTile_Col(colnum, i)
		if tileIndex == nil then
			break
		else
			gameState[i][colnum] = gameState[tileIndex][colnum]
			gameState[tileIndex][colnum] = nil
			table.insert(changedTiles, {tileIndex, colnum})
			local change = tileIndex - i;

			local tile = gameState[i][colnum]["tile"]
			local pos = go.get_position(tile)
			pos["y"]=(tileHeight * change) + go.get_position(tile)["y"]
			go.set_position(pos, tile)
			gameState[i][colnum]["rowNum"] = i
			gameState[i][colnum]["colNum"] = colnum
		end
	end


	

	if #changedTiles == 0 then
		changedTiles = nil
	end
	
	return changedTiles
end

local function ClearTiles(grabbed)
	local colAffected={}
	if grabbed["prev"] ~= nil then
		colAffected = deleteDirection(grabbed["prev"], "prev")
	end

	for col, rowNum in pairs(deleteDirection(grabbed, "next")) do
		if colAffected[col] == nil or colAffected[col] > rowNum then
			colAffected[col] = rowNum
		end
	end

	local change={}
	for colnum, rownum in pairs(colAffected) do
		local tmp =  adjustColumn(colnum, rownum)
		table.insert(change, tmp)
	end

	for i = #gameState, 1, -1 do
		checkEmpty(i)	
	end

	-- Count the colors of the changed tiles to see if there is any other matching pairs. 
	for key, coords_T in ipairs(change) do
		for key, coords in ipairs(coords_T) do

			if gameState[coords[1]] ~= nil then
				local tileData = gameState[coords[1]][coords[2]]
				if tileData ~= nil and countColor(tileData) > minTileMatch then
					ClearTiles(tileData)
				end
			end
		end
	end
	
end

local function Grab(self, message_id, message, sender)

	-- message = {playerPos, action, held TileID}
	local playerPos = message[1] 
	local tileTable = nil 		 -- {rowNumber, TileID}
	local held = message[3]

	-- Find the last row a tile is on.
	local RowNumber = 0
	for RowNumber = #gameState, 1, -1 do
		local row = gameState[RowNumber]
		if row[playerPos] ~= nil then
			tileTable = {RowNumber, row[playerPos]}
			break
		end
	end
	
	
	if held == nil then
		if tileTable ~= nil then
			DisconnectTile(tileTable[1], playerPos)
			grabbed = tileTable[2]
			msg.post(sender, "Grabbed Tile", {tileTable[2]["tile"]})
			gameState[tileTable[1]][playerPos] = nil
			checkEmpty(tileTable[1])
		end
	else
		msg.post(sender, "Grabbed Tile", {nil})
		local newPos = rowPos[playerPos]
		if tileTable == nil then
			-- Column is cleared.  Find a tile on the first row.
			-- 		Should always be a tile on the first row.  Since new row should be spawned if board is cleared.
			
			tileTable = {1, findTile_Row(gameState[1])}
			newPos['y'] = go.get_position(tileTable[2]["tile"])['y']
		else
			local pos = go.get_position(tileTable[2]["tile"])
			newPos['y'] = pos['y'] - tileHeight
			
		end
		
		go.set_position(newPos, grabbed["tile"])



		if gameState[tileTable[1]+1] == nil then
			gameState[tileTable[1]+1] = {}
		end
		gameState[tileTable[1]+1][playerPos] = grabbed
		gameState[tileTable[1]+1][playerPos]["rowNum"] = tileTable[1]+1
		gameState[tileTable[1]+1][playerPos]["colNum"] = playerPos
		ConnectTile(tileTable[1]+1, playerPos)

<<<<<<< Updated upstream

	
		checkConnections(gameState[tileTable[1]+1][playerPos])

		
		if countColor(grabbed) > minTileMatch then

			ClearTiles(grabbed)
			
		end
=======
		--local matchingTiles = countColor(grabbed)
		--if #matchingTiles > capture-1 then

			captureTile(grabbed)

		--end
>>>>>>> Stashed changes


		
	end 



end


function init(self)
	-- Add initialization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
	--self.spawnColorList = {"BlueTile", "GreenTile", "PurpleTile", "RedTile", "YellowTile"}

	math.randomseed(tonumber(hash_to_hex(hash(tostring({}))):sub(4, 8), 16))
	messages[hash("SpeedUp")] = SpeedUp
	messages[hash("getStartPos")] = function(self, message_id, message, sender) msg.post(sender, "returned Positions", rowPos) end
	messages[hash("Grab")] = Grab
	
	
	moveDownTime = const_MoveDownTime
	updateState = GamePlaying
	spawnRow(self)
end

function final(self)
	-- Add finalization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end




function update(self, dt)
	updateState(self, dt)
end

function fixed_update(self, dt)
	-- This function is called if 'Fixed Update Frequency' is enabled in the Engine section of game.project
	-- Can be coupled with fixed updates of the physics simulation if 'Use Fixed Timestep' is enabled in
	-- Physics section of game.project
	-- Add update code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed


end

function on_message(self, message_id, message, sender)
	-- Add message-handling code here
	-- Learn more: https://defold.com/manuals/message-passing/
	-- Remove this function if not needed

	if messages[message_id] ~= nil then

		-- Message recieved from the player script.  Usually when the player requests an interaction with a tile.
		messages[message_id](self, message_id, message, sender)
	end
end

function on_input(self, action_id, action)
	-- Add input-handling code here. The game object this script is attached to
	-- must have acquired input focus:
	--
	--    msg.post(".", "acquire_input_focus")
	--
	-- All mapped input bindings will be received. Mouse and touch input will
	-- be received regardless of where on the screen it happened.
	-- Learn more: https://defold.com/manuals/input/
	-- Remove this function if not needed


end

function on_reload(self)
	-- Add reload-handling code here
	-- Learn more: https://defold.com/manuals/hot-reload/
	-- Remove this function if not needed
end
